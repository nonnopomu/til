## ✅ 今日のサマリ
- 一言：検索機能追加後に落ちたspecを、1本実行→失敗理由の特定→原因の切り分け→検索ロジック/スコープ修正、の流れで潰せた。特に「下書きはArticle.bodyが未生成で検索対象が違う」という設計前提に気づけたのが大きい。
- 達成度：◯（テスト駆動で原因を言語化し、修正方針まで落とし込めた）

## 🧩 やったこと（Issue/PRリンク）
- [x] Web：落ちたsystem specを1本だけ実行して失敗理由を特定（行番号指定）
- [x] Web：フォーム表示/データ/検索ロジックのどこが原因か切り分け
- [x] Web：FormObjectのsearch組み立て（relationに条件を積む）を修正方針として整理
- [x] Web：本文検索が下書きで通らない原因（検索対象テーブルの違い）を特定

## 📚 学んだこと（メモ）
### Web（原因特定：specを最小単位で回す）
- まず「落ちたspecを1本だけ実行して原因を特定する」
  - `rspec ./spec/system/admin_articles_spec.rb:69` のように行番号指定で実行すると、Capybaraの失敗理由が具体的に出る
  - 今回は「selectに '伊藤' が存在しない（`Capybara::ElementNotFound`）」が起点になり、フォーム側/データ側/検索ロジック側のどこが原因か切り分けられた

### Web（View側の落とし穴：selectの表示と“検索が動く”は別）
- `f.select :author_id, User.pluck(:name, :id)` のように書くと、selectの選択肢は `User.name` が表示される
- `users` テーブルに `name` カラムがあるなら、表示カラム自体は間違っていない可能性がある
- ただし、フォームに選択肢が出ていても「検索処理が実装されていない」とテストは通らないケースがある  
  → **表示できる = 機能が完成**ではない

### Web（FormObject：attribute追加だけでは検索は動かない）
- `SearchArticlesForm` に `author_id/tag_id/body` を `attribute` で追加しても、`def search` の中で条件を使わない限り絞り込みは起きない
- つまり「受け取れる状態」と「検索が動く状態」は別物

### Web（searchメソッドの組み立て：relationに条件を積む）
- 追加した条件は `category_id` と同じパターンで積む必要がある
  - `relation = relation.by_author(author_id) if author_id.present?`
  - `relation = relation.by_tag(tag_id) if tag_id.present?`
- “relationを返し続ける”形に揃えると拡張しやすい

### Web（タイトルと本文の検索語は分けて処理する）
- `title_words` のループ内で `body_contain` を呼ぶと意味が混ざる
- 正しくはループを分離する
  - `title_words.each { ... title_contain ... }`
  - `body_words.each  { ... body_contain  ... }`
- `split(nil)` は空白/改行/連続空白をまとめて区切り、検索語を配列化できる（入力ゆらぎ対策）

### Web（下書きだけ本文検索が通らない：scopeの参照先が違う）
- 公開記事は `build_body` により `Article.body` が組み立てられるため、`where('articles.body LIKE ...')` でもヒットする
- 下書き記事は `Article.body` が未生成（nil）なので、そのscopeだとヒットしない
- 本文は `Sentence.body` に保存されているため、下書きも対象にするなら `sentences` 側を検索対象にする必要がある
- 結論：specが落ちた原因は「下書き時は `Article.body` では検索できない」という設計の前提に気づけたこと
